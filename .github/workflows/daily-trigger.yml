name: Daily Trigger

on:
  schedule:
    - cron: "0 3 * * *" # daily at 03:00 UTC
  workflow_dispatch:
  push:
    branches: [ main, test ]
    paths:
      - 'bin/**'
      - '.github/workflows/**'

permissions:
  actions: write
  contents: read

concurrency:
  group: pr-${{ github.head_ref || github.ref }}
  cancel-in-progress: true

jobs:
  trigger:
    if: ${{ github.event_name != 'push' }}
    runs-on: self-hosted
    strategy:
      fail-fast: false
      matrix:
        workflow:
          - "3x-ui-Docker-selfhosted.yml"
          - "Caddy-L4-Docker-selfhosted.yml"
          - "WarpPlus-Docker-Selfhosted.yml"
          - "usque-Docker-selfhosted.yml"
    steps:
      - name: Trigger ${{ matrix.workflow }}
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const workflow = "${{ matrix.workflow }}";

            // ref -> текущая ветка или default_branch
            let ref = (context.ref || '').replace('refs/heads/', '');
            if (!ref) {
              const repoInfo = await github.rest.repos.get({ owner, repo });
              ref = repoInfo.data.default_branch || 'main';
            }

            core.info(`Dispatching ${owner}/${repo}:${ref} -> ${workflow}`);

            // простой ретрай на флейки
            for (let attempt = 1; attempt <= 3; attempt++) {
              try {
                await github.rest.actions.createWorkflowDispatch({ owner, repo, workflow_id: workflow, ref });
                break;
              } catch (e) {
                if (attempt === 3) throw e;
                core.warning(`Dispatch failed (attempt ${attempt}): ${e.message}. Retrying...`);
                await new Promise(r => setTimeout(r, 1000 * attempt));
              }
            }

  route-push:
    if: ${{ github.event_name == 'push' }}
    runs-on: self-hosted
    steps:
      - name: Decide and dispatch sequentially
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;

            // --- helper sleep ---
            const sleep = (ms) => new Promise(r => setTimeout(r, ms));

            // --- get ref/branch name ---
            let ref = (context.ref || '').replace('refs/heads/', '');
            if (!ref) {
              const repoInfo = await github.rest.repos.get({ owner, repo });
              ref = repoInfo.data.default_branch || 'main';
            }

            // --- collect changed files (payload -> fallback compareCommits) ---
            const files = new Set();
            const commits = context.payload?.commits || [];
            for (const c of commits) {
              for (const f of (c.added || []))     files.add(f);
              for (const f of (c.modified || []))  files.add(f);
              for (const f of (c.removed || []))   files.add(f);
            }

            const head = context.sha;
            const base = context.payload?.before;
            if (files.size === 0 && base) {
              try {
                const cmp = await github.rest.repos.compareCommits({ owner, repo, base, head, per_page: 100 });
                for (const f of (cmp.data.files || [])) files.add(f.filename);
              } catch (e) {
                core.warning(`compareCommits failed: ${e.message}`);
              }
            }

            const norm = (p) => p.replace(/^\.\/+/, '').replace(/\\/g, '/');
            const startsWithAny = (file, prefixes) => {
              const fp = norm(file);
              return prefixes.some(p => fp.startsWith(norm(p)));
            };

            const routes = [
              { workflow: 'Caddy-L4-Docker-selfhosted.yml',
                prefixes: ['bin/caddy/', '.github/workflows/Caddy-L4-Docker-selfhosted.yml'] },
              { workflow: '3x-ui-Docker-selfhosted.yml',
                prefixes: ['bin/3x-ui/', '.github/workflows/3x-ui-Docker-selfhosted.yml'] },
              { workflow: 'usque-Docker-selfhosted.yml',
                prefixes: ['bin/usque/', '.github/workflows/usque-Docker-selfhosted.yml'] },
              { workflow: 'WarpPlus-Docker-Selfhosted.yml',
                prefixes: ['bin/warp/', '.github/workflows/WarpPlus-Docker-Selfhosted.yml'] },
            ];

            // --- match all targets ---
            const matched = [];
            for (const r of routes) {
              if ([...files].some(f => startsWithAny(f, r.prefixes))) matched.push(r.workflow);
            }

            if (matched.length === 0) {
              core.info(`No route matched. Changed files: ${[...files].slice(0,20).join(', ')}${files.size>20?'...':''}`);
              return;
            }

            // --- helpers to find and wait for the run we just dispatched ---
            async function listRunsForWorkflow(workflow, {status, per_page=20} = {}) {
              // GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs
              const res = await github.rest.actions.listWorkflowRuns({
                owner, repo, workflow_id: workflow, branch: ref, event: 'workflow_dispatch', status, per_page
              });
              return res.data.workflow_runs || [];
            }

            async function waitForNewRunId(workflow, existingIds, timeoutMs = 5 * 60 * 1000, pollMs = 10_000) {
              const deadline = Date.now() + timeoutMs;
              while (Date.now() < deadline) {
                const runs = await listRunsForWorkflow(workflow, { per_page: 30 });
                const fresh = runs.find(r => !existingIds.has(r.id));
                if (fresh) return fresh.id;
                await sleep(pollMs);
              }
              throw new Error(`Timed out waiting for run to appear for ${workflow}`);
            }

            async function waitForRunCompletion(workflow, runId, timeoutMs = 6 * 60 * 60 * 1000, pollMs = 15_000) {
              const deadline = Date.now() + timeoutMs;
              while (Date.now() < deadline) {
                const { data: run } = await github.rest.actions.getWorkflowRun({ owner, repo, run_id: runId });
                if (run.status === 'completed') {
                  core.info(`Run ${runId} of ${workflow} completed with conclusion: ${run.conclusion}`);
                  return run.conclusion; // success | failure | cancelled | skipped | etc.
                }
                await sleep(pollMs);
              }
              throw new Error(`Timed out waiting for completion of run ${runId} (${workflow})`);
            }

            // --- sequential dispatch & wait ---
            for (const workflow of matched) {
              core.info(`Preparing to dispatch ${workflow} on ref ${ref}`);

              // snapshot current run ids to identify the new one
              const beforeRuns = await listRunsForWorkflow(workflow, { per_page: 50 });
              const beforeIds = new Set(beforeRuns.map(r => r.id));

              // dispatch with small retries
              let dispatched = false;
              for (let attempt = 1; attempt <= 3; attempt++) {
                try {
                  await github.rest.actions.createWorkflowDispatch({ owner, repo, workflow_id: workflow, ref });
                  dispatched = true;
                  break;
                } catch (e) {
                  if (attempt === 3) throw e;
                  core.warning(`Dispatch failed for ${workflow} (attempt ${attempt}): ${e.message}. Retrying...`);
                  await sleep(1000 * attempt);
                }
              }

              if (!dispatched) continue;

              // find the new run id
              let runId;
              try {
                runId = await waitForNewRunId(workflow, beforeIds);
              } catch (e) {
                core.warning(`Couldn't detect new run for ${workflow}: ${e.message}. Proceeding to next.`);
                continue; // идём дальше, не блокируем цепочку
              }

              // wait until completed (любой результат)
              try {
                await waitForRunCompletion(workflow, runId);
              } catch (e) {
                core.warning(`Wait failed for ${workflow} (run ${runId}): ${e.message}. Proceeding to next.`);
              }

              // небольшая пауза между задачами
              await sleep(1000);
            }
